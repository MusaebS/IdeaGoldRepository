### File: .devcontainer/devcontainer.json
```
{
  "name": "Python 3",
  // Or use a Dockerfile or Docker Compose file. More info: https://containers.dev/guide/dockerfile
  "image": "mcr.microsoft.com/devcontainers/python:1-3.11-bullseye",
  "customizations": {
    "codespaces": {
      "openFiles": [
        "README.md",
        "app.py"
      ]
    },
    "vscode": {
      "settings": {},
      "extensions": [
        "ms-python.python",
        "ms-python.vscode-pylance"
      ]
    }
  },
  "updateContentCommand": "[ -f packages.txt ] && sudo apt update && sudo apt upgrade -y && sudo xargs apt install -y <packages.txt; [ -f requirements.txt ] && pip3 install --user -r requirements.txt; pip3 install --user streamlit; echo '✅ Packages installed and Requirements met'",
  "postAttachCommand": {
    "server": "streamlit run app.py --server.enableCORS false --server.enableXsrfProtection false"
  },
  "portsAttributes": {
    "8501": {
      "label": "Application",
      "onAutoForward": "openPreview"
    }
  },
  "forwardPorts": [
    8501
  ]
}```

### File: .gitignore
```
# Byte-compiled / optimized / DLL files
__pycache__/
*.py[cod]
*$py.class

# C extensions
*.so

# Distribution / packaging
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
share/python-wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# PyInstaller
#  Usually these files are written by a python script from a template
#  before PyInstaller builds the exe, so as to inject date/other infos into it.
*.manifest
*.spec

# Installer logs
pip-log.txt
pip-delete-this-directory.txt

# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py,cover
.hypothesis/
.pytest_cache/
cover/

# Translations
*.mo
*.pot

# Django stuff:
*.log
local_settings.py
db.sqlite3
db.sqlite3-journal

# Flask stuff:
instance/
.webassets-cache

# Scrapy stuff:
.scrapy

# Sphinx documentation
docs/_build/

# PyBuilder
.pybuilder/
target/

# Jupyter Notebook
.ipynb_checkpoints

# IPython
profile_default/
ipython_config.py

# pyenv
#   For a library or package, you might want to ignore these files since the code is
#   intended to run in multiple environments; otherwise, check them in:
# .python-version

# pipenv
#   According to pypa/pipenv#598, it is recommended to include Pipfile.lock in version control.
#   However, in case of collaboration, if having platform-specific dependencies or dependencies
#   having no cross-platform support, pipenv may install dependencies that don't work, or not
#   install all needed dependencies.
#Pipfile.lock

# UV
#   Similar to Pipfile.lock, it is generally recommended to include uv.lock in version control.
#   This is especially recommended for binary packages to ensure reproducibility, and is more
#   commonly ignored for libraries.
#uv.lock

# poetry
#   Similar to Pipfile.lock, it is generally recommended to include poetry.lock in version control.
#   This is especially recommended for binary packages to ensure reproducibility, and is more
#   commonly ignored for libraries.
#   https://python-poetry.org/docs/basic-usage/#commit-your-poetrylock-file-to-version-control
#poetry.lock

# pdm
#   Similar to Pipfile.lock, it is generally recommended to include pdm.lock in version control.
#pdm.lock
#   pdm stores project-wide configurations in .pdm.toml, but it is recommended to not include it
#   in version control.
#   https://pdm.fming.dev/latest/usage/project/#working-with-version-control
.pdm.toml
.pdm-python
.pdm-build/

# PEP 582; used by e.g. github.com/David-OConnor/pyflow and github.com/pdm-project/pdm
__pypackages__/

# Celery stuff
celerybeat-schedule
celerybeat.pid

# SageMath parsed files
*.sage.py

# Environments
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# Spyder project settings
.spyderproject
.spyproject

# Rope project settings
.ropeproject

# mkdocs documentation
/site

# mypy
.mypy_cache/
.dmypy.json
dmypy.json

# Pyre type checker
.pyre/

# pytype static type analyzer
.pytype/

# Cython debug symbols
cython_debug/

# PyCharm
#  JetBrains specific template is maintained in a separate JetBrains.gitignore that can
#  be found at https://github.com/github/gitignore/blob/main/Global/JetBrains.gitignore
#  and can be added to the global gitignore or merged into this file.  For a more nuclear
#  option (not recommended) you can uncomment the following to ignore the entire idea folder.
#.idea/

# Ruff stuff:
.ruff_cache/

# PyPI configuration file
.pypirc
```

### File: README.md
```
# Idea Gold Scheduler

This project builds on OR-Tools to generate fair on-call schedules. Install `ortools` from the requirements file to enable the CP-SAT optimiser.

If `ortools` is missing, the stub solver marks all shifts as **Unfilled**. This ensures the app still runs but signals that optimisation isn't available.

The time limit for solving depends on the environment. Set the `ENV` variable to
`dev`, `test`, or `prod` (default) for 10s, 1s or 60s respectively.
Enable the **Test mode** checkbox in the app to load example shifts and participant names automatically.
The solver supports fractional fairness targets via `InputData.target_total`, `target_label`, and `target_weekend`. It minimises the largest deviation from these targets before minimising smaller gaps and unfilled shifts. This keeps point totals balanced whenever possible.

If `target_total` or `target_weekend` are not provided, `build_schedule` calculates
them automatically. It divides the total points and weekend points for the block
evenly among all listed residents and assigns these values back on the `InputData`
object before solving. For example:

```python
data = InputData(
    start_date=date(2025, 1, 1),
    end_date=date(2025, 1, 7),
    shifts=[ShiftTemplate(label="D", role="Junior", night_float=False, thu_weekend=False, points=1.0)],
    juniors=["A", "B"],
    seniors=[],
    nf_juniors=[],
    nf_seniors=[],
    leaves=[],
    rotators=[],
    min_gap=1,
)
schedule = build_schedule(data)
# data.target_total and data.target_weekend now hold the computed shares
```

The results page includes a **Download Fairness Log** button. It saves a text file summarising each resident's role, night float points, total and weekend points, along with any deviations from the targets you entered.

## Changelog
- Removed unused `extra_oncalls` field from `InputData`.
```

### File: Specs, always read before advancing
```
Idea Gold Scheduler – Exact-Fairness Optimiser
(specification rev 2025-05-xx – replaces previous heuristic / Hare-Niemeyer design)

1 Project Goal
Create a Streamlit tool that produces a provably most-balanced on-call schedule for one 4-week block.
Balance is measured in points (each shift template carries a points value).

Fairness target	Requirement
Per-label points	Every resident’s points on each label should equal their fractional share as closely as mathematically possible.
Weekend points	Weekend load is balanced so that residents differ by ≤ 1 weekend point whenever feasible.
Total points	Across all labels, the difference between any two full-participation residents is minimised; ideal bound is ± 1 point.
If perfect equality is impossible	The optimiser returns the schedule with minimum possible deviation and reports residual gaps.

2 Hard Constraints
Shift templates
label, role (Junior / Senior), night_float flag, thu_is_weekend flag, points.

Participants
Lists of juniors and seniors; per-resident flag for night-float eligibility.

Absences

Leave – compensated (quota unchanged).

Rotator – uncompensated (quotas scaled by active_days / block_span).

Night-float blocks
Fixed length nf_block_length; only NF-eligible residents may cover them.

Rest spacing
A resident must have ≥ min_gap days between any two shifts, regardless of label.

Role match
Juniors cannot fill senior shifts and vice-versa.

One assignment per slot
Each (day, label) must be covered by exactly one resident.

3 Optimisation Model (Mixed-Integer Programming)
Symbol	Definition
R	residents
D	days in block
L	shift labels
x[r,d,l] ∈ {0,1}	1 ⇔ resident r works label l on day d
P[l]	points value of label l
W[d,l]	1 ⇔ (d,l) is a weekend slot

Derived sums
Copy
Edit
label_pts[r,l]   = Σ_d P[l]·x[r,d,l]
total_pts[r]     = Σ_l label_pts[r,l]
weekend_pts[r]   = Σ_{d,l|W[d,l]=1} P[l]·x[r,d,l]
Target values
Fractional targets t_label[r,l], t_total, t_weekend[r] come from proportional shares (e.g. Hare-Niemeyer fractions) but are not forced; deviations are penalised.

Additional variables
less
Copy
Edit
dev_label[r,l]  ≥ |label_pts[r,l]  − t_label[r,l] |
dev_total[r]    ≥ |total_pts[r]    − t_total      |
dev_weekend[r]  ≥ |weekend_pts[r]  − t_weekend[r]|
max_dev         ≥ dev_total[r]     ∀ r
Objective (lexicographic)
Minimise max_dev (tightest overall-points spread).

Then minimise Σ dev_total.

Then minimise Σ dev_weekend.

Then minimise Σ dev_label.

Finally minimise number of dummy “Unfilled” slots (should be zero).

(Implementation may instead use a single weighted sum with weights W1 ≫ W2 ≫ W3 ≫ W4 to mimic the same priority.)

Solver
Use OR-Tools CP-SAT (open-source, handles ≥ 10k binaries easily).
Typical solve time ≤ 60 s for 40 residents × 28 days × 10 labels on Streamlit Cloud.

4 Tech Stack
Layer	Choice / Notes
Language	Python 3.11
Optimiser	OR-Tools 9.x CP-SAT
UI	Streamlit ≥ 1.33 (layout="wide")
Data	pandas 2.x (tables, CSV)
Deployment	Any Python host (Streamlit Cloud, on-prem); multi-file repo

requirements.txt

shell
Copy
Edit
streamlit>=1.33
pandas>=2.0
ortools>=9.10
5 Recommended File Layout
bash
Copy
Edit
idea-gold/
├─ app.py                 # Streamlit UI
├─ model/
│   ├─ optimiser.py       # build & solve CP-SAT model
│   └─ data_models.py     # dataclasses or TypedDicts
├─ docs/
│   └─ spec.md            # ← this document
└─ requirements.txt
Session-state keys stay unchanged (plus any solver settings you expose: time-limit, random seed).

6 User Flow
Open web app.

Configure shift templates (with points), participants, absences, min_gap, NF block length.

Click “Generate Schedule”.

App shows a spinner (“Optimising…”), runs the CP-SAT solver, then displays:

Schedule table (st.dataframe)

Per-label and total point summaries

Weekend balance report

Fairness deviations (should be ≤ 1 where feasible)

CSV / JSON downloads.

If the model is infeasible (e.g. constraints too tight), UI displays solver status and highlights which rule failed.
Implementation Progress (2025-07)
- Added deviation variables for per-label, total, and weekend points
- Objective now minimises the largest deviation before smaller gaps and unfilled shifts
- `InputData` gained optional targets for these values
- Removed unused `extra_oncalls` field from `InputData`
- `build_schedule` computes default total and weekend targets when left unset



7 Outstanding / Future Work
UI seed control & load/save configuration JSON.

Optional “soften min_gap” slider when infeasible.

Unit tests: small synthetic blocks where optimal solution is known.

Performance benchmark page (solve-time vs. residents).
```

### File: app.py
```
import streamlit as st
import pandas as pd
from datetime import date, timedelta

from model.data_models import ShiftTemplate, InputData
from model.optimiser import build_schedule
from model.fairness import format_fairness_log
from model.demo_data import sample_shifts, sample_names
import os

st.set_page_config(page_title="Idea Gold Scheduler", layout="wide")
st.title("Idea Gold Scheduler – CP-SAT")

# Session defaults
if "shifts" not in st.session_state:
    st.session_state.shifts = []
if "juniors" not in st.session_state:
    st.session_state.juniors = []
if "seniors" not in st.session_state:
    st.session_state.seniors = []
if "nf_juniors" not in st.session_state:
    st.session_state.nf_juniors = []
if "nf_seniors" not in st.session_state:
    st.session_state.nf_seniors = []
if "demo_loaded" not in st.session_state:
    st.session_state.demo_loaded = False

# optional sample data for quick testing
test_mode = st.checkbox("Test mode (preload example data)")
if test_mode and not st.session_state.demo_loaded:
    st.session_state.shifts = sample_shifts()
    juniors, seniors, nf_juniors, nf_seniors = sample_names()
    st.session_state.juniors = juniors
    st.session_state.seniors = seniors
    st.session_state.nf_juniors = nf_juniors
    st.session_state.nf_seniors = nf_seniors
    st.session_state.demo_loaded = True

st.header("Configuration")

with st.expander("Shift Templates", expanded=True):
    label = st.text_input("Label")
    role = st.selectbox("Role", ["Junior", "Senior"])
    nf = st.checkbox("Night Float")
    thu_wk = st.checkbox("Thu counts as weekend")
    points = st.number_input("Points", 1.0, 10.0, 1.0, 0.5)
    if st.button("Add Shift", key="add_shift"):
        st.session_state.shifts.append(
            ShiftTemplate(label=label, role=role, night_float=nf, thu_weekend=thu_wk, points=points)
        )
    if st.session_state.shifts:
        st.table(pd.DataFrame([s.__dict__ for s in st.session_state.shifts]))
        del_opts = list(range(len(st.session_state.shifts)))
        del_idx = st.selectbox(
            "Delete shift", del_opts,
            format_func=lambda i: st.session_state.shifts[i].label,
        )
        if st.button("Delete Shift", key="del_shift"):
            st.session_state.shifts.pop(del_idx)

cols = st.columns(2)
with cols[0]:
    st.subheader("Participants")
    juniors_text = st.text_area("Juniors", "\n".join(st.session_state.juniors))
    seniors_text = st.text_area("Seniors", "\n".join(st.session_state.seniors))
    st.session_state.juniors = [n.strip() for n in juniors_text.splitlines() if n.strip()]
    st.session_state.seniors = [n.strip() for n in seniors_text.splitlines() if n.strip()]

with cols[1]:
    st.subheader("Night Float Eligible")
    st.session_state.nf_juniors = st.multiselect(
        "Juniors", st.session_state.juniors, default=st.session_state.nf_juniors
    )
    st.session_state.nf_seniors = st.multiselect(
        "Seniors", st.session_state.seniors, default=st.session_state.nf_seniors
    )

date_cols = st.columns(2)
with date_cols[0]:
    start_date = st.date_input("Start Date", date.today())
with date_cols[1]:
    end_date = st.date_input("End Date", date.today() + timedelta(days=27))
min_gap = st.slider("Minimum Gap", 0, 7, 1)
nf_block_len = st.number_input("NF Block Length", 1, 7, 5)

if st.button("Generate Schedule"):
    data = InputData(
        start_date=start_date,
        end_date=end_date,
        shifts=st.session_state.shifts,
        juniors=st.session_state.juniors,
        seniors=st.session_state.seniors,
        nf_juniors=st.session_state.nf_juniors,
        nf_seniors=st.session_state.nf_seniors,
        leaves=[],
        rotators=[],
        min_gap=min_gap,
        nf_block_length=nf_block_len,
    )
    try:
        env = os.getenv("ENV", "prod")
        df = build_schedule(data, env=env)
        st.dataframe(df)
        log_text = format_fairness_log(df, data)
        st.download_button("Download Fairness Log", log_text, file_name="fairness_log.txt")
        if st.checkbox("Show Fairness Log"):
            st.text(log_text)
    except Exception as e:
        st.error(str(e))
```

### File: model/__init__.py
```
from .optimiser import build_schedule, respects_min_gap
from .nf_blocks import respects_nf_blocks
from .fairness import format_fairness_log, calculate_points

```

### File: model/data_models.py
```
from dataclasses import dataclass
from datetime import date
from typing import List, Tuple, Dict


@dataclass
class ShiftTemplate:
    label: str
    role: str  # 'Junior' or 'Senior'
    night_float: bool
    thu_weekend: bool
    points: float = 1.0


@dataclass
class InputData:
    start_date: date
    end_date: date
    shifts: List[ShiftTemplate]
    juniors: List[str]
    seniors: List[str]
    nf_juniors: List[str]
    nf_seniors: List[str]
    leaves: List[Tuple[str, date, date]]
    rotators: List[Tuple[str, date, date]]
    min_gap: int = 1
    nf_block_length: int = 5
    target_label: Dict[tuple[str, str], float] | None = None
    target_total: float | None = None
    target_weekend: Dict[str, float] | None = None

```

### File: model/demo_data.py
```
from .data_models import ShiftTemplate


def sample_shifts():
    """Return preset shift templates for test mode."""
    return [
        ShiftTemplate(label="Junior night float", role="Junior", night_float=True, thu_weekend=False),
        ShiftTemplate(label="Senior night float", role="Senior", night_float=True, thu_weekend=False),
        ShiftTemplate(label="ER night", role="Junior", night_float=False, thu_weekend=True),
        ShiftTemplate(label="Ward night", role="Junior", night_float=False, thu_weekend=True),
        ShiftTemplate(label="Senior night", role="Senior", night_float=False, thu_weekend=True),
        ShiftTemplate(label="evening shift", role="Senior", night_float=False, thu_weekend=False),
        ShiftTemplate(label="morning shift", role="Senior", night_float=False, thu_weekend=False),
        ShiftTemplate(label="Ward morning", role="Junior", night_float=False, thu_weekend=False),
        ShiftTemplate(label="ER zone 1 morning", role="Junior", night_float=False, thu_weekend=False),
        ShiftTemplate(label="ER zone 2 morning", role="Junior", night_float=False, thu_weekend=False),
    ]


def sample_names():
    """Return demo participant lists and NF eligibility subsets."""
    juniors = [
        "Alice", "Ben", "Carla", "Derek", "Eva", "Frank", "Grace",
        "Hector", "Isla", "Jack", "Kira", "Liam", "Mia", "Noah", "Olivia",
        "Paul", "Quinn", "Rosa", "Sam", "Tara", "Umar", "Violet", "Wes",
        "Xena", "Yara", "Zane", "Aaron", "Bella", "Caleb", "Dana",
    ]
    seniors = [
        "Erin", "Felix", "Gina", "Harold", "Ivy", "Jonah", "Karen",
        "Leo", "Monica", "Nathan", "Opal", "Perry", "Ruth", "Simon", "Tanya",
    ]

    # Simple subsets to indicate night float eligibility
    nf_juniors = juniors[:10]
    nf_seniors = seniors[:5]

    return juniors, seniors, nf_juniors, nf_seniors
```

### File: model/fairness.py
```
from __future__ import annotations

from typing import Dict, List

try:
    import pandas as pd
except ImportError:  # pragma: no cover - fallback when pandas missing
    from .pandas_stub import pd

from .data_models import ShiftTemplate, InputData
from .utils import is_weekend

__all__ = ["calculate_points", "format_fairness_log"]


def calculate_points(df: pd.DataFrame, data: InputData) -> Dict[str, Dict[str, float]]:
    """Return mapping of resident to total and weekend points per label."""
    summary: Dict[str, Dict[str, float]] = {
        name: {"total": 0.0, "weekend": 0.0, "labels": {}, "night_float": 0.0}
        for name in data.juniors + data.seniors
    }
    for row in df.to_dict("records"):
        day = row.get("Date")
        for sh in data.shifts:
            person = row.get(sh.label)
            if person in (None, "Unfilled"):
                continue
            info = summary.setdefault(person, {"total": 0.0, "weekend": 0.0, "labels": {}, "night_float": 0.0})
            info["total"] += sh.points
            info["labels"][sh.label] = info["labels"].get(sh.label, 0.0) + sh.points
            if sh.night_float:
                info["night_float"] += sh.points
            if is_weekend(day, sh):
                info["weekend"] += sh.points
    return summary


def format_fairness_log(df: pd.DataFrame, data: InputData) -> str:
    """Generate a human-readable fairness log."""
    pts = calculate_points(df, data)
    lines: List[str] = []
    for person in sorted(pts):
        info = pts[person]
        role = "Senior" if person in data.seniors else "Junior"
        nf = info.get("night_float", 0.0)
        line = f"{person} ({role}, NF {nf:.1f}): total {info['total']:.1f}"
        if data.target_total is not None:
            dev = info['total'] - data.target_total
            line += f" (dev {dev:+.1f})"
        line += f", weekend {info['weekend']:.1f}"
        if data.target_weekend and person in data.target_weekend:
            wdev = info['weekend'] - data.target_weekend[person]
            line += f" (dev {wdev:+.1f})"
        for label in sorted(info['labels']):
            val = info['labels'][label]
            line += f", {label} {val:.1f}"
            if data.target_label and (person, label) in data.target_label:
                ldev = val - data.target_label[(person, label)]
                line += f" (dev {ldev:+.1f})"
        lines.append(line)
    totals = [v['total'] for v in pts.values()]
    if totals:
        lines.append(f"Total point range: {max(totals) - min(totals):.1f}")
    wk_totals = [v['weekend'] for v in pts.values()]
    if wk_totals:
        lines.append(f"Weekend point range: {max(wk_totals) - min(wk_totals):.1f}")
    return "\n".join(lines)
```

### File: model/nf_blocks.py
```
from __future__ import annotations

from datetime import date
from typing import Dict, List

try:
    import pandas as pd
except ImportError:  # pragma: no cover - fallback when pandas missing
    from .pandas_stub import pd

from .data_models import ShiftTemplate

__all__ = ["respects_nf_blocks"]


def respects_nf_blocks(
    df: pd.DataFrame,
    nf_block_length: int,
    shifts: List[ShiftTemplate],
) -> bool:
    """Return True if NF assignments occur in fixed-length blocks."""
    if nf_block_length <= 1:
        return True
    nf_labels = [s.label for s in shifts if s.night_float]
    if not nf_labels:
        return True

    assignments: Dict[str, Dict[str, List[date]]] = {}
    for row in df.to_dict("records"):
        day = row.get("Date")
        for label in nf_labels:
            person = row.get(label)
            if person in (None, "Unfilled"):
                continue
            assignments.setdefault(person, {}).setdefault(label, []).append(day)

    for label_assignments in assignments.values():
        for days in label_assignments.values():
            days.sort()
            run_len = 1
            prev = days[0]
            for d in days[1:]:
                if (d - prev).days == 1:
                    run_len += 1
                else:
                    if run_len != nf_block_length:
                        return False
                    run_len = 1
                prev = d
            if run_len != nf_block_length:
                return False
    return True
```

### File: model/optimiser.py
```
from datetime import timedelta
import os
from typing import Dict, Tuple

try:
    import pandas as pd
except ImportError:  # pragma: no cover - fallback when pandas missing
    from .pandas_stub import pd

try:
    from ortools.sat.python import cp_model
except ImportError:  # pragma: no cover - simple fallback if ortools missing
    class _Var:
        def __init__(self):
            self.value = 0

        def __add__(self, other):
            if isinstance(other, _Var):
                return self.value + other.value
            return self.value + other

        __radd__ = __add__

        def __mul__(self, other):
            if isinstance(other, _Var):
                return self.value * other.value
            return self.value * other

        __rmul__ = __mul__

        def __sub__(self, other):
            if isinstance(other, _Var):
                return self.value - other.value
            return self.value - other

        def __rsub__(self, other):
            if isinstance(other, _Var):
                return other.value - self.value
            return other - self.value

        def __ge__(self, other):
            if isinstance(other, _Var):
                return self.value >= other.value
            return self.value >= other

        def __le__(self, other):
            if isinstance(other, _Var):
                return self.value <= other.value
            return self.value <= other

        def __gt__(self, other):
            if isinstance(other, _Var):
                return self.value > other.value
            return self.value > other

        def __lt__(self, other):
            if isinstance(other, _Var):
                return self.value < other.value
            return self.value < other

    class CpModel:
        def NewBoolVar(self, name):
            return _Var()

        def Add(self, constraint):
            pass

        def NewIntVar(self, a, b, name):
            return _Var()

        def Minimize(self, expr):
            pass

    class CpSolver:
        OPTIMAL = 0
        FEASIBLE = 0
        INFEASIBLE = 1
        MODEL_INVALID = 2
        UNKNOWN = 3

        def __init__(self):
            self.parameters = type("p", (), {})()
            self.parameters.max_time_in_seconds = 0

        def Solve(self, model):
            # Dummy assignment: mark every shift as unfilled
            if hasattr(model, 'vars'):
                people = model.people
                days = model.days
                shifts = model.shifts
                unfilled_idx = len(people) - 1
                for d_idx in range(len(days)):
                    for s_idx in range(len(shifts)):
                        for p_idx in range(len(people)):
                            v = model.vars[(p_idx, d_idx, s_idx)]
                            v.value = 0
                        model.vars[(unfilled_idx, d_idx, s_idx)].value = 1
            return self.OPTIMAL

        def StatusName(self, status):
            names = {
                self.OPTIMAL: "OPTIMAL",
                self.FEASIBLE: "FEASIBLE",
                self.INFEASIBLE: "INFEASIBLE",
                self.MODEL_INVALID: "MODEL_INVALID",
                self.UNKNOWN: "UNKNOWN",
            }
            return names.get(status, str(status))

        def Value(self, var):
            return var.value

    cp_model = type(
        "cp_model",
        (),
        {
            "CpModel": CpModel,
            "CpSolver": CpSolver,
            "OPTIMAL": CpSolver.OPTIMAL,
            "FEASIBLE": CpSolver.FEASIBLE,
            "INFEASIBLE": CpSolver.INFEASIBLE,
            "MODEL_INVALID": CpSolver.MODEL_INVALID,
            "UNKNOWN": CpSolver.UNKNOWN,
        },
    )

from .data_models import InputData, ShiftTemplate
from .nf_blocks import respects_nf_blocks
from .utils import is_weekend


class SchedulerSolver:
    def __init__(self, data: InputData):
        self.data = data
        self.model = cp_model.CpModel()
        self.SCALE = 100
        self.people = data.juniors + data.seniors + ["Unfilled"]
        self.days = [data.start_date + timedelta(days=i)
                     for i in range((data.end_date - data.start_date).days + 1)]
        self.shifts = data.shifts
        self.labels = sorted({s.label for s in data.shifts})
        self.vars: Dict[Tuple[int, int, int], object] = {}
        self.label_pts: Dict[Tuple[int, str], object] = {}
        self.total_pts: Dict[int, object] = {}
        self.weekend_pts: Dict[int, object] = {}
        self.dev_label: Dict[Tuple[int, str], object] = {}
        self.dev_total: Dict[int, object] = {}
        self.dev_weekend: Dict[int, object] = {}
        self.max_dev: object | None = None
        self.build_variables()
        self.compute_points()
        # expose internals for stub solver (may fail on real CpModel)
        try:
            self.model.people = self.people
            self.model.days = self.days
            self.model.shifts = self.shifts
            self.model.vars = self.vars
            self.model.label_pts = self.label_pts
            self.model.total_pts = self.total_pts
            self.model.weekend_pts = self.weekend_pts
            self.model.dev_label = self.dev_label
            self.model.dev_total = self.dev_total
            self.model.dev_weekend = self.dev_weekend
            self.model.max_dev = self.max_dev
        except AttributeError:
            # Real ortools model does not allow setting new attributes
            pass
        self.add_constraints()
        self.add_deviation_constraints()
        self.build_objective()

    def build_variables(self) -> None:
        for p_idx in range(len(self.people)):
            for d_idx in range(len(self.days)):
                for s_idx in range(len(self.shifts)):
                    self.vars[(p_idx, d_idx, s_idx)] = self.model.NewBoolVar(
                        f"x_{p_idx}_{d_idx}_{s_idx}")

    def _mul(self, var, coef: int):
        if coef <= 0:
            return 0
        expr = var
        for _ in range(coef - 1):
            expr = expr + var
        return expr

    def _max_points(self) -> int:
        """Return scaled upper bound for point totals."""
        total_points = sum(s.points for s in self.shifts)
        return max(1, len(self.days) * int(100 * total_points))

    def compute_points(self) -> None:
        scale = self.SCALE
        max_val = self._max_points()
        for p_idx, _ in enumerate(self.people[:-1]):
            for label in self.labels:
                parts = []
                for d_idx in range(len(self.days)):
                    for s_idx, sh in enumerate(self.shifts):
                        if sh.label != label:
                            continue
                        coef = int(round(sh.points * scale))
                        parts.append(self._mul(self.vars[(p_idx, d_idx, s_idx)], coef))
                expr = sum(parts) if parts else 0
                var = self.model.NewIntVar(0, max_val, f"labelpts_{p_idx}_{label}")
                self.model.Add(var == expr)
                self.label_pts[(p_idx, label)] = var

            tot_expr = sum(self.label_pts[(p_idx, l)] for l in self.labels)
            tvar = self.model.NewIntVar(0, max_val, f"totalpts_{p_idx}")
            self.model.Add(tvar == tot_expr)
            self.total_pts[p_idx] = tvar

            wk_parts = []
            for d_idx, day in enumerate(self.days):
                for s_idx, sh in enumerate(self.shifts):
                    if not is_weekend(day, sh):
                        continue
                    coef = int(round(sh.points * scale))
                    wk_parts.append(self._mul(self.vars[(p_idx, d_idx, s_idx)], coef))
            wk_expr = sum(wk_parts) if wk_parts else 0
            wvar = self.model.NewIntVar(0, max_val, f"weekendpts_{p_idx}")
            self.model.Add(wvar == wk_expr)
            self.weekend_pts[p_idx] = wvar

    def add_deviation_constraints(self) -> None:
        scale = self.SCALE
        max_val = self._max_points()

        if self.data.target_total is not None:
            target = int(round(self.data.target_total * scale))
            for p_idx in range(len(self.people) - 1):
                var = self.model.NewIntVar(0, max_val, f"dev_total_{p_idx}")
                self.model.Add(var >= self.total_pts[p_idx] - target)
                self.model.Add(var >= target - self.total_pts[p_idx])
                self.dev_total[p_idx] = var
            self.max_dev = self.model.NewIntVar(0, max_val, "max_dev")
            for var in self.dev_total.values():
                self.model.Add(self.max_dev >= var)

        if self.data.target_weekend:
            for p_idx, person in enumerate(self.people[:-1]):
                if person not in self.data.target_weekend:
                    continue
                target = int(round(self.data.target_weekend[person] * scale))
                var = self.model.NewIntVar(0, max_val, f"dev_weekend_{p_idx}")
                self.model.Add(var >= self.weekend_pts[p_idx] - target)
                self.model.Add(var >= target - self.weekend_pts[p_idx])
                self.dev_weekend[p_idx] = var

        if self.data.target_label:
            for p_idx, person in enumerate(self.people[:-1]):
                for label in self.labels:
                    key = (person, label)
                    if key not in self.data.target_label:
                        continue
                    target = int(round(self.data.target_label[key] * scale))
                    var = self.model.NewIntVar(0, max_val, f"dev_label_{p_idx}_{label}")
                    lp = self.label_pts[(p_idx, label)]
                    self.model.Add(var >= lp - target)
                    self.model.Add(var >= target - lp)
                    self.dev_label[(p_idx, label)] = var

    def add_constraints(self) -> None:
        for d_idx, day in enumerate(self.days):
            for s_idx, shift in enumerate(self.shifts):
                # exactly one assignment per slot
                self.model.Add(
                    sum(self.vars[(p_idx, d_idx, s_idx)]
                        for p_idx in range(len(self.people))) == 1
                )
                for p_idx, person in enumerate(self.people[:-1]):  # exclude Unfilled
                    # role eligibility
                    if shift.role == "Junior" and person not in self.data.juniors:
                        self.model.Add(self.vars[(p_idx, d_idx, s_idx)] == 0)
                    if shift.role == "Senior" and person not in self.data.seniors:
                        self.model.Add(self.vars[(p_idx, d_idx, s_idx)] == 0)
                    # night float eligibility
                    if shift.night_float:
                        if shift.role == "Junior" and person not in self.data.nf_juniors:
                            self.model.Add(self.vars[(p_idx, d_idx, s_idx)] == 0)
                        if shift.role == "Senior" and person not in self.data.nf_seniors:
                            self.model.Add(self.vars[(p_idx, d_idx, s_idx)] == 0)
                    # leaves
                    for res, start, end in self.data.leaves:
                        if res == person and start <= day <= end:
                            self.model.Add(self.vars[(p_idx, d_idx, s_idx)] == 0)

        # min_gap spacing
        gap = self.data.min_gap
        if gap > 0:
            for p_idx, _ in enumerate(self.people[:-1]):  # exclude Unfilled
                # no more than one shift per day
                for d_idx in range(len(self.days)):
                    self.model.Add(
                        sum(
                            self.vars[(p_idx, d_idx, s_idx)]
                            for s_idx in range(len(self.shifts))
                        )
                        <= 1
                    )
                for d1_idx, day1 in enumerate(self.days):
                    for d2_idx in range(d1_idx + 1, len(self.days)):
                        if (self.days[d2_idx] - day1).days <= gap:
                            for s1_idx in range(len(self.shifts)):
                                for s2_idx in range(len(self.shifts)):
                                    self.model.Add(
                                        self.vars[(p_idx, d1_idx, s1_idx)] +
                                        self.vars[(p_idx, d2_idx, s2_idx)] <= 1
                                    )

        # night float blocks must have exact length
        block_len = self.data.nf_block_length
        if block_len > 1:
            nf_shift_idxs = [i for i, s in enumerate(self.shifts) if s.night_float]
            for s_idx in nf_shift_idxs:
                for block_start in range(0, len(self.days), block_len):
                    block_days = list(range(block_start, min(block_start + block_len, len(self.days))))
                    if len(block_days) < block_len:
                        for d_idx in block_days:
                            for p_idx in range(len(self.people) - 1):
                                self.model.Add(self.vars[(p_idx, d_idx, s_idx)] == 0)
                        continue
                    for p_idx in range(len(self.people)):
                        first_var = self.vars[(p_idx, block_days[0], s_idx)]
                        for d_idx in block_days[1:]:
                            self.model.Add(first_var == self.vars[(p_idx, d_idx, s_idx)])
                for boundary in range(block_len, len(self.days), block_len):
                    if boundary >= len(self.days):
                        break
                    prev_day = boundary - 1
                    next_day = boundary
                    for p_idx in range(len(self.people)):
                        self.model.Add(
                            self.vars[(p_idx, prev_day, s_idx)] + self.vars[(p_idx, next_day, s_idx)] <= 1
                        )

    def build_objective(self) -> None:
        unfilled_vars = [
            self.vars[(len(self.people) - 1, d_idx, s_idx)]
            for d_idx in range(len(self.days))
            for s_idx in range(len(self.shifts))
        ]

        terms = []
        W1, W2, W3, W4, W5 = 10**9, 10**6, 10**3, 10, 1
        if self.max_dev is not None:
            terms.append(W1 * self.max_dev)
        if self.dev_total:
            terms.append(W2 * sum(self.dev_total.values()))
        if self.dev_weekend:
            terms.append(W3 * sum(self.dev_weekend.values()))
        if self.dev_label:
            terms.append(W4 * sum(self.dev_label.values()))
        terms.append(W5 * sum(unfilled_vars))

        self.model.Minimize(sum(terms))

    def solve(self, time_limit_sec: int | None = None):
        solver = cp_model.CpSolver()
        if time_limit_sec:
            solver.parameters.max_time_in_seconds = time_limit_sec
        status = solver.Solve(self.model)
        if status not in (cp_model.OPTIMAL, cp_model.FEASIBLE):
            name_func = getattr(solver, "StatusName", lambda s: str(s))
            raise RuntimeError(f"Solver ended with status {name_func(status)}")
        rows = []
        for d_idx, day in enumerate(self.days):
            row = {"Date": day, "Day": day.strftime("%A")}
            for s_idx, shift in enumerate(self.shifts):
                assigned = None
                for p_idx, person in enumerate(self.people):
                    if solver.Value(self.vars[(p_idx, d_idx, s_idx)]):
                        assigned = person
                        break
                row[shift.label] = assigned
            rows.append(row)
        return pd.DataFrame(rows)


def build_schedule(data: InputData, env: str | None = None) -> pd.DataFrame:
    """Build schedule with optional environment based time limit."""
    participants = data.juniors + data.seniors
    if participants:
        days = (data.end_date - data.start_date).days + 1
        total_points = days * sum(s.points for s in data.shifts)
        weekend_points = 0.0
        for i in range(days):
            day = data.start_date + timedelta(days=i)
            for s in data.shifts:
                if is_weekend(day, s):
                    weekend_points += s.points
        if data.target_total is None:
            data.target_total = total_points / len(participants)
        if data.target_weekend is None:
            share = weekend_points / len(participants)
            data.target_weekend = {p: share for p in participants}

    solver = SchedulerSolver(data)
    env = env or os.environ.get("ENV", "prod").lower()
    if env == "dev":
        limit = 10
    elif env == "test":
        limit = 1
    else:
        limit = 60
    df = solver.solve(time_limit_sec=limit)
    if not respects_min_gap(df, data.min_gap):
        raise RuntimeError("Schedule violates min_gap constraint")
    if not respects_nf_blocks(df, data.nf_block_length, data.shifts):
        raise RuntimeError("Schedule violates nf_block_length constraint")
    return df


def respects_min_gap(df: pd.DataFrame, gap: int) -> bool:
    """Return True if no resident appears on days ``gap`` or fewer apart."""
    if gap <= 0:
        return True
    assignments: Dict[str, list] = {}
    records = df.to_dict("records")
    if hasattr(df, "columns"):
        shift_cols = []
        for c in df.columns:
            if c in {"Date", "Day"}:
                continue
            try:
                if getattr(df[c], "dtype", object) != object:
                    continue
            except Exception:
                pass
            shift_cols.append(c)
    else:
        first = records[0] if records else {}
        shift_cols = [k for k in first.keys() if k not in {"Date", "Day"}]

    for row in records:
        day = row.get("Date")
        for label in shift_cols:
            person = row.get(label)
            if person in (None, "Unfilled") or not isinstance(person, str):
                continue
            assignments.setdefault(person, []).append(day)
    for days in assignments.values():
        days.sort()
        for d1, d2 in zip(days, days[1:]):
            if (d2 - d1).days <= gap:
                return False
    return True


```

### File: model/pandas_stub.py
```
class SimpleDataFrame(list):
    """Very small subset of pandas.DataFrame used for testing without pandas."""
    def __init__(self, data=None):
        super().__init__(data or [])

    def to_dict(self, orient="records"):
        return list(self)

    def __getitem__(self, key):
        return [row.get(key) for row in self]

# Provide a minimal pd-like namespace
pd = type("pd", (), {"DataFrame": SimpleDataFrame})()
```

### File: model/utils.py
```
from __future__ import annotations

from datetime import date

from .data_models import ShiftTemplate

__all__ = ["is_weekend"]


def is_weekend(day: date, shift: ShiftTemplate) -> bool:
    """Return True if the given day/shift counts as a weekend."""
    return day.weekday() >= 5 or (shift.thu_weekend and day.weekday() == 3)
```

### File: requirements.txt
```
streamlit>=1.33
pandas>=2.0
ortools>=9.10
```

### File: tests/conftest.py
```
import pytest


@pytest.fixture
def strict_cp(monkeypatch):
    """Patch optimiser.cp_model with a model that forbids new attributes."""
    from model import optimiser as opt

    class _Var:
        __slots__ = ("value",)

        def __init__(self):
            self.value = 0

        def __add__(self, other):
            if isinstance(other, _Var):
                return self.value + other.value
            return self.value + other

        __radd__ = __add__
        __mul__ = __add__
        __rmul__ = __mul__
        __sub__ = __add__
        __rsub__ = __add__
        __ge__ = lambda self, other: True
        __le__ = __ge__

    class StrictModel:
        __slots__ = ()

        def NewBoolVar(self, name):
            return _Var()

        def Add(self, constraint):
            pass

        def NewIntVar(self, a, b, name):
            return _Var()

        def Minimize(self, expr):
            pass

    class StubSolver(opt.cp_model.CpSolver):
        pass

    stub_cp = type(
        "cp_model",
        (),
        {"CpModel": StrictModel, "CpSolver": StubSolver, "OPTIMAL": 0, "FEASIBLE": 0},
    )
    monkeypatch.setattr(opt, "cp_model", stub_cp)
    return stub_cp


@pytest.fixture
def balanced_cp(monkeypatch):
    """Patch optimiser.cp_model with a solver that evenly rotates residents."""
    from model import optimiser as opt

    class BalancedSolver(opt.cp_model.CpSolver):
        def Solve(self, model):
            num_res = len(model.people) - 1
            for d_idx in range(len(model.days)):
                for s_idx in range(len(model.shifts)):
                    p_idx = (d_idx + s_idx) % num_res
                    for idx in range(len(model.people)):
                        model.vars[(idx, d_idx, s_idx)].value = int(idx == p_idx)
            return self.OPTIMAL

    stub_cp = type(
        "cp_model",
        (),
        {
            "CpModel": opt.cp_model.CpModel,
            "CpSolver": BalancedSolver,
            "OPTIMAL": 0,
            "FEASIBLE": 0,
        },
    )
    monkeypatch.setattr(opt, "cp_model", stub_cp)
    return stub_cp
```

### File: tests/test_fairness.py
```
import sys, os
from datetime import date
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
try:
    import pandas as pd
except Exception:
    from model import optimiser as opt
    pd = opt.pd

from model.data_models import ShiftTemplate, InputData
from model.fairness import calculate_points, format_fairness_log


def _sample_df_and_shifts():
    shifts = [
        ShiftTemplate(label="D", role="Junior", night_float=False, thu_weekend=False, points=1.0),
        ShiftTemplate(label="N", role="Junior", night_float=False, thu_weekend=False, points=2.0),
    ]
    df = pd.DataFrame([
        {"Date": date(2023, 1, 7), "D": "Alice", "N": "Bob"},
        {"Date": date(2023, 1, 8), "D": "Bob", "N": "Alice"},
    ])
    return df, shifts


def test_calculate_points():
    df, shifts = _sample_df_and_shifts()
    data = InputData(
        start_date=date(2023, 1, 7),
        end_date=date(2023, 1, 8),
        shifts=shifts,
        juniors=["Alice", "Bob"],
        seniors=[],
        nf_juniors=[],
        nf_seniors=[],
        leaves=[],
        rotators=[],
        min_gap=1,
    )
    pts = calculate_points(df, data)
    assert pts == {
        "Alice": {
            "total": 3.0,
            "weekend": 3.0,
            "labels": {"D": 1.0, "N": 2.0},
            "night_float": 0.0,
        },
        "Bob": {
            "total": 3.0,
            "weekend": 3.0,
            "labels": {"D": 1.0, "N": 2.0},
            "night_float": 0.0,
        },
    }


def test_format_fairness_log():
    df, shifts = _sample_df_and_shifts()
    data = InputData(
        start_date=date(2023, 1, 7),
        end_date=date(2023, 1, 8),
        shifts=shifts,
        juniors=["Alice", "Bob"],
        seniors=[],
        nf_juniors=[],
        nf_seniors=[],
        leaves=[],
        rotators=[],
        min_gap=1,
        target_total=3.0,
    )
    log = format_fairness_log(df, data)
    expected_lines = [
        "Alice (Junior, NF 0.0): total 3.0 (dev +0.0), weekend 3.0, D 1.0, N 2.0",
        "Bob (Junior, NF 0.0): total 3.0 (dev +0.0), weekend 3.0, D 1.0, N 2.0",
        "Total point range: 0.0",
        "Weekend point range: 0.0",
    ]
    assert log.splitlines() == expected_lines
```

### File: tests/test_optimiser.py
```
import sys, os
from datetime import date
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
try:
    import pandas as pd
except Exception:
    from model import optimiser as opt
    pd = opt.pd

from model.data_models import ShiftTemplate, InputData
from model.optimiser import build_schedule, respects_min_gap
from model.nf_blocks import respects_nf_blocks


def test_simple_schedule():
    data = InputData(
        start_date=date(2023, 1, 1),
        end_date=date(2023, 1, 2),
        shifts=[ShiftTemplate(label="Shift1", role="Junior", night_float=False, thu_weekend=False, points=1.0)],
        juniors=["A", "B"],
        seniors=[],
        nf_juniors=[],
        nf_seniors=[],
        leaves=[],
        rotators=[],
        min_gap=1,
    )
    df = build_schedule(data)
    assert len(df) == 2
    assert set(df["Shift1"]) <= {"A", "B", "Unfilled"}
    assert list(df["Day"]) == ["Sunday", "Monday"]


def test_schedule_with_strict_cpmodel(strict_cp):
    """Scheduler should not fail if CpModel disallows new attributes."""

    from model import optimiser as opt

    data = InputData(
        start_date=date(2023, 1, 1),
        end_date=date(2023, 1, 1),
        shifts=[ShiftTemplate(label="S1", role="Junior", night_float=False, thu_weekend=False)],
        juniors=["A"],
        seniors=[],
        nf_juniors=[],
        nf_seniors=[],
        leaves=[],
        rotators=[],
        min_gap=1,
    )

    df = opt.build_schedule(data)
    assert len(df) == 1


def test_role_and_gap_constraints():
    data = InputData(
        start_date=date(2023, 1, 1),
        end_date=date(2023, 1, 2),
        shifts=[ShiftTemplate(label="S1", role="Senior", night_float=True, thu_weekend=False)],
        juniors=["A"],
        seniors=["B"],
        nf_juniors=["A"],
        nf_seniors=[],  # B cannot cover night float
        leaves=[],
        rotators=[],
        min_gap=2,
        nf_block_length=1,
    )

    df = build_schedule(data)
    # Only unfilled is eligible due to NF restriction; also min_gap prevents A working both days
    assert set(df["S1"]) == {"Unfilled"}


def test_respects_min_gap_function():
    df = pd.DataFrame([
        {"Date": date(2023, 1, 1), "S1": "A"},
        {"Date": date(2023, 1, 2), "S1": "A"},
    ])
    assert not respects_min_gap(df, 2)

    df = pd.DataFrame([
        {"Date": date(2023, 1, 1), "S1": "A"},
        {"Date": date(2023, 1, 3), "S1": "A"},
    ])
    assert not respects_min_gap(df, 2)

    df = pd.DataFrame([
        {"Date": date(2023, 1, 1), "S1": "A"},
        {"Date": date(2023, 1, 4), "S1": "A"},
    ])
    assert respects_min_gap(df, 2)


def test_respects_min_gap_with_day_column():
    df = pd.DataFrame([
        {"Date": date(2023, 1, 1), "Day": "Sunday", "S1": "A"},
        {"Date": date(2023, 1, 4), "Day": "Wednesday", "S1": "A"},
    ])
    assert respects_min_gap(df, 2)


def test_respects_nf_blocks_function():
    shifts = [ShiftTemplate(label="NF", role="Junior", night_float=True, thu_weekend=False)]
    df = pd.DataFrame([
        {"Date": date(2023, 1, 1), "NF": "A"},
        {"Date": date(2023, 1, 2), "NF": "A"},
        {"Date": date(2023, 1, 3), "NF": "A"},
    ])
    assert respects_nf_blocks(df, 3, shifts)

    df = pd.DataFrame([
        {"Date": date(2023, 1, 1), "NF": "A"},
        {"Date": date(2023, 1, 2), "NF": "A"},
        {"Date": date(2023, 1, 3), "NF": "B"},
    ])
    assert not respects_nf_blocks(df, 3, shifts)


def test_nf_blocks_exact_assignment():
    data = InputData(
        start_date=date(2023, 1, 1),
        end_date=date(2023, 1, 3),
        shifts=[ShiftTemplate(label="NF", role="Junior", night_float=True, thu_weekend=False)],
        juniors=["A"],
        seniors=[],
        nf_juniors=["A"],
        nf_seniors=[],
        leaves=[],
        rotators=[],
        min_gap=0,
        nf_block_length=2,
    )

    df = build_schedule(data, env="test")
    rows = df.to_dict("records")
    assert rows[2]["NF"] == "Unfilled"
    assert rows[0]["NF"] == rows[1]["NF"]
    assert respects_nf_blocks(df, 2, data.shifts)


def _points_by_resident(df: pd.DataFrame, shifts: list[ShiftTemplate]) -> dict:
    pts: dict[str, float] = {}
    for row in df.to_dict("records"):
        for s in shifts:
            p = row.get(s.label)
            if p and p != "Unfilled":
                pts[p] = pts.get(p, 0.0) + s.points
    return pts


def test_total_points_balanced(balanced_cp):
    from model import optimiser as opt

    shifts = [ShiftTemplate(label="D", role="Junior", night_float=False, thu_weekend=False, points=1.0)]
    data = InputData(
        start_date=date(2023, 1, 1),
        end_date=date(2023, 1, 2),
        shifts=shifts,
        juniors=["A", "B"],
        seniors=[],
        nf_juniors=[],
        nf_seniors=[],
        leaves=[],
        rotators=[],
        min_gap=0,
        target_total=1.0,
    )

    df = opt.build_schedule(data, env="test")
    pts = _points_by_resident(df, shifts)
    assert abs(pts.get("A", 0) - pts.get("B", 0)) <= 1


def test_total_points_min_deviation(balanced_cp):
    from model import optimiser as opt

    shifts = [ShiftTemplate(label="D", role="Junior", night_float=False, thu_weekend=False, points=1.0)]
    data = InputData(
        start_date=date(2023, 1, 1),
        end_date=date(2023, 1, 3),
        shifts=shifts,
        juniors=["A", "B"],
        seniors=[],
        nf_juniors=[],
        nf_seniors=[],
        leaves=[],
        rotators=[],
        min_gap=0,
        target_total=1.5,
    )

    df = opt.build_schedule(data, env="test")
    pts = _points_by_resident(df, shifts)
    diff = abs(pts.get("A", 0) - pts.get("B", 0))
    assert diff == 1


def test_intvar_upper_bound_multiple_shifts(monkeypatch):
    from model import optimiser as opt

    bounds = []

    class RecordingModel(opt.cp_model.CpModel):
        def NewIntVar(self, a, b, name):
            bounds.append(b)
            return super().NewIntVar(a, b, name)

    stub_cp = type(
        "cp_model",
        (),
        {
            "CpModel": RecordingModel,
            "CpSolver": opt.cp_model.CpSolver,
            "OPTIMAL": 0,
            "FEASIBLE": 0,
        },
    )
    monkeypatch.setattr(opt, "cp_model", stub_cp)

    shifts = [
        ShiftTemplate(label="S1", role="Junior", night_float=False, thu_weekend=False, points=1.0),
        ShiftTemplate(label="S2", role="Junior", night_float=False, thu_weekend=False, points=2.0),
    ]
    data = InputData(
        start_date=date(2023, 1, 1),
        end_date=date(2023, 1, 1),
        shifts=shifts,
        juniors=["A"],
        seniors=[],
        nf_juniors=[],
        nf_seniors=[],
        leaves=[],
        rotators=[],
        min_gap=0,
        target_total=3.0,
    )

    opt.build_schedule(data, env="test")
    days = (data.end_date - data.start_date).days + 1
    expected = days * int(100 * sum(s.points for s in shifts))
    assert expected in bounds


def test_total_points_balanced_multiple_shifts(balanced_cp):
    from model import optimiser as opt

    shifts = [
        ShiftTemplate(label="D1", role="Junior", night_float=False, thu_weekend=False, points=1.0),
        ShiftTemplate(label="D2", role="Junior", night_float=False, thu_weekend=False, points=2.0),
    ]
    data = InputData(
        start_date=date(2023, 1, 1),
        end_date=date(2023, 1, 2),
        shifts=shifts,
        juniors=["A", "B"],
        seniors=[],
        nf_juniors=[],
        nf_seniors=[],
        leaves=[],
        rotators=[],
        min_gap=0,
    )

    df = opt.build_schedule(data, env="test")
    pts = _points_by_resident(df, shifts)
    assert abs(pts.get("A", 0) - pts.get("B", 0)) <= 1


def test_default_targets_balance_points(balanced_cp):
    from model import optimiser as opt
    from model.fairness import calculate_points

    shifts = [ShiftTemplate(label="D", role="Junior", night_float=False, thu_weekend=False, points=1.0)]
    data = InputData(
        start_date=date(2023, 1, 6),
        end_date=date(2023, 1, 8),
        shifts=shifts,
        juniors=["A", "B"],
        seniors=[],
        nf_juniors=[],
        nf_seniors=[],
        leaves=[],
        rotators=[],
        min_gap=0,
    )

    df = opt.build_schedule(data, env="test")
    pts = calculate_points(df, data)
    totals = [v["total"] for v in pts.values()]
    weekends = [v["weekend"] for v in pts.values()]

    assert max(totals) - min(totals) <= 1
    assert max(weekends) - min(weekends) <= 1


def test_fairness_log_includes_unused_resident():
    from model.fairness import format_fairness_log

    data = InputData(
        start_date=date(2023, 1, 1),
        end_date=date(2023, 1, 2),
        shifts=[ShiftTemplate(label="S", role="Junior", night_float=False, thu_weekend=False, points=1.0)],
        juniors=["A", "B"],
        seniors=[],
        nf_juniors=[],
        nf_seniors=[],
        leaves=[],
        rotators=[],
        min_gap=0,
    )
    df = pd.DataFrame([
        {"Date": date(2023, 1, 1), "S": "A"},
        {"Date": date(2023, 1, 2), "S": "A"},
    ])
    log = format_fairness_log(df, data)
    lines = log.splitlines()
    assert any(line.startswith("A (Junior, NF 0.0): total 2.0") for line in lines)
    assert any(line.startswith("B (Junior, NF 0.0): total 0.0") for line in lines)


def test_auto_target_computation():
    data = InputData(
        start_date=date(2023, 1, 2),
        end_date=date(2023, 1, 2),
        shifts=[ShiftTemplate(label="S", role="Junior", night_float=False, thu_weekend=False, points=1.0)],
        juniors=["A", "B"],
        seniors=[],
        nf_juniors=[],
        nf_seniors=[],
        leaves=[],
        rotators=[],
        min_gap=0,
    )
    assert data.target_total is None
    assert data.target_weekend is None
    build_schedule(data, env="test")
    assert data.target_total == 0.5
    assert data.target_weekend == {"A": 0.0, "B": 0.0}
```

